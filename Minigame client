----------------------------------------
-- Minigameservice
-- Made by; moudithedev (Comms; moudi_gamer)
-- 23/08/2025
----------------------------------------


-- gets the services I need
local Players=game:GetService("Players")
local RS=game:GetService("ReplicatedStorage")

-- makes the remote events so the server is able to talk to the client
local PromptRE=RS:FindFirstChild("MiniGamePromptRE") or Instance.new("RemoteEvent",RS)
PromptRE.Name="MiniGamePromptRE"
local JoinRE=RS:FindFirstChild("MiniGameJoinRE") or Instance.new("RemoteEvent",RS)
JoinRE.Name="MiniGameJoinRE"
local StartRE=RS:FindFirstChild("MiniGameStartRE") or Instance.new("RemoteEvent",RS)
StartRE.Name="MiniGameStartRE"
local EndRE=RS:FindFirstChild("MiniGameEndRE") or Instance.new("RemoteEvent",RS)
EndRE.Name="MiniGameEndRE"

-- settings for the minigame
local INTERVAL=30 -- how often (in seconds) it sends the prompt
local DURATION=120 -- how long the game will last for (in seconds)
local ACCEPT_WINDOW=10 -- how long the player has to click yes ( in seconds)

-- gets the stuff from the workspace
local arena=workspace:WaitForChild("MiniGame_Teleport")
local exitPad=workspace:WaitForChild("MiniGame_Return")
local coinsFolder=workspace:WaitForChild("MiniGameCoins")

-- keeps track of whos playing and the coin connections
local active={}
local coinConns={}

-- basically this makes the coins when its touched
local function bindCoin(p)
	if not p:IsA("BasePart") then return end -- discounts the old one if it exists
	if coinConns[p] then coinConns[p]:Disconnect() end
	coinConns[p]=p.Touched:Connect(function(hit)
		local plr=Players:GetPlayerFromCharacter(hit.Parent)
		if not plr or not active[plr] then return end -- only works if they're in game
		local ls=plr:FindFirstChild("leaderstats"); if not ls then return end
		local c=ls:FindFirstChild("Coins"); if not c then return end
		local r=p:GetAttribute("Reward") or 1 -- gets the coin value
		c.Value+=r -- adds the coins
		p:Destroy() -- deletes the coin
	end)
end

-- Connects all the coins that exist
for _,d in ipairs(coinsFolder:GetDescendants()) do bindCoin(d) end
coinsFolder.DescendantAdded:Connect(bindCoin) -- connects the new coins as well

-- teleports the player to the part
local function tp(plr,part)
	local ch=plr.Character; if not ch then return end
	local hrp=ch:FindFirstChild("HumanoidRootPart"); if not hrp then return end
	hrp.CFrame=part.CFrame+Vector3.new(0,3,0) -- moves the player up a bit
end

-- starting the mini game
local function startFor(plr)
	if active[plr] then return end -- doesnt restart if their already playing
	active[plr]=true
	local endsAt=os.time()+DURATION -- when it ends
	tp(plr,arena) -- the player gets sent to the arenea
	StartRE:FireClient(plr,endsAt) -- tells the client to show the timerr
	task.delay(DURATION,function()
		if not active[plr] then return end
		active[plr]=nil
		tp(plr,exitPad) -- teleports them back
		EndRE:FireClient(plr) -- sends a message to the client thats its over
	end)
end

-- fires when player clicks yes
JoinRE.OnServerEvent:Connect(function(plr)
	if active[plr] then return end
	startFor(plr)
end)

-- loop that keeps asking players to join
task.spawn(function()
	while true do
		task.wait(INTERVAL)
		for _,plr in ipairs(Players:GetPlayers()) do
			if not active[plr] then -- only asks people not in the game currently
				PromptRE:FireClient(plr,ACCEPT_WINDOW)
			end
		end
		task.wait(ACCEPT_WINDOW)
	end
end)

Players.PlayerRemoving:Connect(function(p) active[p]=nil end)

